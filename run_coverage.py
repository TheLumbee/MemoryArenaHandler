#!/usr/bin/env python
"""
Automates the process of generating an LLVM code coverage report for a CMake project.

This script should be placed in the root directory of your CMake project.

It performs the following steps:
1. Configures CMake with code coverage flags for the Clang compiler.
2. Builds the project using the specified generator (e.g., Ninja).
3. Runs tests using CTest. Can run all tests or a specific labeled subgroup.
4. Merges the raw profile data generated by the test run.
5. Generates a detailed HTML coverage report using llvm-cov.

Requirements:
- Python 3.6+
- CMake
- Ninja (or another build tool, configurable)
- clang, llvm-profdata, llvm-cov in your system's PATH.
- xdg-open (optional, for auto-opening reports on Linux)

Example Usage:
----------------
# Run coverage on 'src/libmy_math.a'
python run_coverage.py src/libmy_math.a

# Run coverage for only the tests labeled 'addition'
python run_coverage.py src/libmy_math.a --label addition

# Run coverage and open the report immediately
python run_coverage.py src/libmy_math.a --open
"""

import argparse
import os
import shutil
import subprocess
from pathlib import Path

# --- Configuration ---
# You can change these default values
BUILD_DIR = "coverage_build"
COMPILER = "clang++"
GENERATOR = "Ninja"


def run_command(command, cwd, env=None):
    """Executes a command and checks for errors."""
    # Ensure all items in command are strings for printing and execution
    str_command = [str(item) for item in command]
    try:
        subprocess.run(
            str_command,
            check=True,
            cwd=cwd,
            env=env,
            text=True,
        )
    except FileNotFoundError:
        print(f"Error: Command '{command[0]}' not found. Is it in your PATH?")
        exit(1)
    except subprocess.CalledProcessError as e:
        print(f"Error: Command failed with exit code {e.returncode}")
        exit(1)


def configure_cmake(project_root):
    """Configures the CMake project with coverage options."""
    print("--- Step 1: Configuring CMake ---")
    build_path = project_root / BUILD_DIR
    if not build_path.exists():
        build_path.mkdir()

    cmake_command = [
        "cmake",
        "-S", ".",
        "-B", str(build_path),
        f"-G", GENERATOR,
        f"-DCMAKE_CXX_COMPILER={COMPILER}",
        "-DENABLE_CODE_COVERAGE=ON",
        "-DCMAKE_BUILD_TYPE=Debug"
    ]
    run_command(cmake_command, cwd=project_root)


def build_project(project_root):
    """Builds the project using CMake's build command."""
    print("\n--- Step 2: Building Project ---")
    build_path = project_root / BUILD_DIR
    build_command = ["cmake", "--build", str(build_path)]
    run_command(build_command, cwd=project_root)


def run_tests(project_root, label=None):
    """Runs tests with CTest and generates raw coverage data."""
    print("\n--- Step 3: Running Tests ---")
    build_path = project_root / BUILD_DIR

    # Set up environment for LLVM to create separate .profraw files
    test_env = os.environ.copy()
    test_env["LLVM_PROFILE_FILE"] = "coverage-%p.profraw"

    ctest_command = ["ctest", "--output-on-failure"]
    if label:
        print(f"Running tests with label: {label}")
        ctest_command.extend(["-L", label])
    else:
        print("Running all tests.")

    run_command(ctest_command, cwd=build_path, env=test_env)


def generate_report(project_root, target_binary, open_report):
    """Merges coverage data and generates an HTML report."""
    print("\n--- Step 4: Generating Coverage Report ---")
    build_path = project_root / BUILD_DIR
    report_dir = build_path / "coverage_report"

    # Find all raw profile data files recursively
    profraw_files = list(build_path.glob("**/coverage-*.profraw"))
    if not profraw_files:
        print("Error: No .profraw coverage files found. Did the tests run correctly?")
        exit(1)

    # 1. Merge the raw profiles into a single .profdata file
    profdata_file = build_path / "coverage.profdata"
    merge_command = [
        "llvm-profdata", "merge", "-sparse",
        *profraw_files,
        "-o", str(profdata_file)
    ]
    run_command(merge_command, cwd=build_path)

    # 2. Generate the HTML report
    target_path = build_path / target_binary
    if not target_path.exists():
        print(f"Error: Target binary '{target_path}' not found!")
        print("Please ensure the binary path argument is correct.")
        exit(1)
        
    # Modified regex: Added '|log\\.[ch]' to ignore log.c and log.h
    report_command = [
        "llvm-cov", "show", str(target_path),
        f"-instr-profile={profdata_file}",
        "--format=html",
        "--ignore-filename-regex=(_deps|tests|test|build|liahona)", 
        "--show-line-counts-or-regions",
        "--show-instantiations",
        f"-o", str(report_dir)
    ]
    run_command(report_command, cwd=build_path)

    report_index = report_dir / "index.html"
    print("\n--- Coverage Report Generation Complete! ---")
    print(f"View the report by opening:\n{report_index.resolve()}")

    if open_report:
        print("Opening report using xdg-open...")
        run_command(["xdg-open", str(report_index)], cwd=report_dir)


def main():
    """Main function to parse arguments and orchestrate the workflow."""
    parser = argparse.ArgumentParser(description="Automate code coverage generation.")
    
    # Position argument for the binary path (previously --target-binary)
    parser.add_argument(
        "binary_path",
        help="Path to the instrumented binary (library or executable) to analyze, "
             "relative to the build directory. E.g., 'src/libmy_math.a'"
    )

    parser.add_argument(
        "-L", "--label",
        help="Run a specific subgroup of tests using a CTest label."
    )

    parser.add_argument(
        "--open",
        action="store_true",
        help="Automatically open the generated HTML report using xdg-open."
    )

    args = parser.parse_args()
    project_root = Path(__file__).parent.resolve()

    configure_cmake(project_root)
    build_project(project_root)
    run_tests(project_root, args.label)
    generate_report(project_root, args.binary_path, args.open)


if __name__ == "__main__":
    main()
